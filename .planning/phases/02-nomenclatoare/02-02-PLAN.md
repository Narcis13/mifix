---
phase: 02-nomenclatoare
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/server/src/routes/gestiuni.ts
  - packages/server/src/index.ts
  - packages/client/src/pages/Gestiuni.tsx
  - packages/client/src/components/nomenclatoare/GestiuniForm.tsx
autonomous: true

must_haves:
  truths:
    - "User can see list of gestiuni in a table"
    - "User can create a new gestiune via dialog form"
    - "User can edit an existing gestiune"
    - "User can toggle gestiune activ/inactiv status"
    - "Form validates required fields and shows errors"
  artifacts:
    - path: "packages/server/src/routes/gestiuni.ts"
      provides: "Gestiuni CRUD API endpoints"
      exports: ["gestiuniRoutes"]
    - path: "packages/client/src/pages/Gestiuni.tsx"
      provides: "Gestiuni list with DataTable"
      min_lines: 80
    - path: "packages/client/src/components/nomenclatoare/GestiuniForm.tsx"
      provides: "Create/Edit gestiune dialog form"
      min_lines: 60
  key_links:
    - from: "packages/client/src/pages/Gestiuni.tsx"
      to: "/api/gestiuni"
      via: "api.get/post/put"
      pattern: "api\\.(get|post|put).*gestiuni"
    - from: "packages/server/src/routes/gestiuni.ts"
      to: "packages/server/src/db/schema.ts"
      via: "Drizzle query"
      pattern: "db\\.(select|insert|update).*gestiuni"
---

<objective>
Implement full CRUD for Gestiuni nomenclator (NOM-01): API endpoints + UI with list, create, edit.

Purpose: Gestiuni is the foundational nomenclator - other nomenclatoare (Locuri, MijloaceFixe) depend on it. This establishes the CRUD pattern for all other nomenclatoare.
Output: Working gestiuni management: list, create, edit, toggle active status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-nomenclatoare/02-RESEARCH.md
@.planning/phases/02-nomenclatoare/02-01-SUMMARY.md

@packages/server/src/db/schema.ts
@packages/server/src/validation/schemas.ts
@packages/server/src/index.ts
@packages/client/src/lib/api.ts
@packages/client/src/components/data-table/DataTable.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Gestiuni API routes</name>
  <files>
    packages/server/src/routes/gestiuni.ts
    packages/server/src/index.ts
  </files>
  <action>
    1. Create packages/server/src/routes/gestiuni.ts:
       - Import Hono, zValidator from @hono/zod-validator
       - Import db, gestiuni table, insertGestiuneSchema
       - Implement endpoints:

       GET /
       - Return all gestiuni ordered by cod
       - Response: ApiResponse<Gestiune[]>

       GET /:id
       - Return single gestiune by id
       - Return 404 if not found
       - Response: ApiResponse<Gestiune>

       POST /
       - Validate body with zValidator("json", insertGestiuneSchema)
       - Insert new gestiune
       - Use db.insert(gestiuni).values(data).$returningId()
       - Fetch and return the created gestiune
       - Response: ApiResponse<Gestiune>

       PUT /:id
       - Validate body (partial schema for updates)
       - Update gestiune by id
       - Return 404 if not found
       - Response: ApiResponse<Gestiune>

       Example structure:
       ```typescript
       import { Hono } from "hono";
       import { zValidator } from "@hono/zod-validator";
       import { eq } from "drizzle-orm";
       import { db } from "../db";
       import { gestiuni } from "../db/schema";
       import { insertGestiuneSchema } from "../validation/schemas";
       import type { ApiResponse, Gestiune } from "shared";

       export const gestiuniRoutes = new Hono();

       gestiuniRoutes.get("/", async (c) => {
         const result = await db.select().from(gestiuni).orderBy(gestiuni.cod);
         return c.json<ApiResponse<Gestiune[]>>({ success: true, data: result });
       });

       gestiuniRoutes.post("/",
         zValidator("json", insertGestiuneSchema),
         async (c) => {
           const data = c.req.valid("json");
           const [{ id }] = await db.insert(gestiuni).values(data).$returningId();
           const [created] = await db.select().from(gestiuni).where(eq(gestiuni.id, id));
           return c.json<ApiResponse<Gestiune>>({ success: true, data: created }, 201);
         }
       );
       // ... PUT /:id similarly
       ```

    2. Update packages/server/src/index.ts:
       - Import gestiuniRoutes
       - Mount at /api/gestiuni: `app.route("/api/gestiuni", gestiuniRoutes);`
  </action>
  <verify>
    - `bun run --cwd packages/server lint` passes
    - Start server: `bun run --cwd packages/server dev`
    - Test GET: `curl http://localhost:3000/api/gestiuni` returns empty array with success:true
    - Test POST: `curl -X POST http://localhost:3000/api/gestiuni -H "Content-Type: application/json" -d '{"cod":"G001","denumire":"Gestiune Test"}'` returns created gestiune
    - Test GET again: returns the created gestiune in array
  </verify>
  <done>
    Gestiuni API endpoints working: GET all, GET by id, POST create, PUT update.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Gestiuni UI with DataTable and Form dialog</name>
  <files>
    packages/client/src/pages/Gestiuni.tsx
    packages/client/src/components/nomenclatoare/GestiuniForm.tsx
  </files>
  <action>
    1. Create packages/client/src/components/nomenclatoare/GestiuniForm.tsx:
       - Dialog-based form for create/edit gestiune
       - Use react-hook-form with zodResolver
       - Form fields: cod (required), denumire (required), responsabil (optional), activ (checkbox)
       - Props: open, onOpenChange, gestiune (optional for edit mode), onSuccess callback
       - On submit: call api.post or api.put depending on mode
       - Reset form on success and call onSuccess
       - Example structure:
         ```typescript
         import { useForm } from "react-hook-form";
         import { zodResolver } from "@hookform/resolvers/zod";
         import { z } from "zod";
         import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
         import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
         import { Input } from "@/components/ui/input";
         import { Button } from "@/components/ui/button";
         import { api } from "@/lib/api";
         import type { Gestiune } from "shared";

         const formSchema = z.object({
           cod: z.string().min(1, "Cod obligatoriu").max(20),
           denumire: z.string().min(1, "Denumire obligatorie").max(200),
           responsabil: z.string().max(200).optional(),
           activ: z.boolean().default(true),
         });

         interface Props {
           open: boolean;
           onOpenChange: (open: boolean) => void;
           gestiune?: Gestiune;
           onSuccess: () => void;
         }
         ```

    2. Update packages/client/src/pages/Gestiuni.tsx:
       - Replace placeholder with full implementation
       - Fetch gestiuni on mount using useEffect + api.get
       - Define columns for DataTable: cod, denumire, responsabil, activ (as badge), actions (edit button)
       - "Adauga Gestiune" button opens create dialog
       - Edit button in row opens edit dialog with gestiune data
       - Refresh list on create/edit success
       - Example structure:
         ```typescript
         import { useState, useEffect } from "react";
         import { DataTable } from "@/components/data-table/DataTable";
         import { GestiuniForm } from "@/components/nomenclatoare/GestiuniForm";
         import { Button } from "@/components/ui/button";
         import { api } from "@/lib/api";
         import type { Gestiune } from "shared";
         import { ColumnDef } from "@tanstack/react-table";

         export function Gestiuni() {
           const [gestiuni, setGestiuni] = useState<Gestiune[]>([]);
           const [dialogOpen, setDialogOpen] = useState(false);
           const [editingGestiune, setEditingGestiune] = useState<Gestiune | undefined>();

           const loadGestiuni = async () => {
             const res = await api.get<Gestiune[]>("/gestiuni");
             if (res.success && res.data) setGestiuni(res.data);
           };

           useEffect(() => { loadGestiuni(); }, []);

           const columns: ColumnDef<Gestiune>[] = [
             { accessorKey: "cod", header: "Cod" },
             { accessorKey: "denumire", header: "Denumire" },
             { accessorKey: "responsabil", header: "Responsabil" },
             { accessorKey: "activ", header: "Activ", cell: ({ row }) => row.original.activ ? "Da" : "Nu" },
             {
               id: "actions",
               cell: ({ row }) => (
                 <Button variant="ghost" size="sm" onClick={() => { setEditingGestiune(row.original); setDialogOpen(true); }}>
                   Editeaza
                 </Button>
               ),
             },
           ];

           return (
             <div className="container mx-auto py-6">
               <div className="flex justify-between items-center mb-4">
                 <h1 className="text-2xl font-bold">Gestiuni</h1>
                 <Button onClick={() => { setEditingGestiune(undefined); setDialogOpen(true); }}>
                   Adauga Gestiune
                 </Button>
               </div>
               <DataTable columns={columns} data={gestiuni} />
               <GestiuniForm
                 open={dialogOpen}
                 onOpenChange={setDialogOpen}
                 gestiune={editingGestiune}
                 onSuccess={() => { setDialogOpen(false); loadGestiuni(); }}
               />
             </div>
           );
         }
         ```
  </action>
  <verify>
    - `bun run --cwd packages/client lint` passes
    - Start dev: `bun run dev` (from root with Turbo)
    - Navigate to http://localhost:5173/gestiuni
    - Click "Adauga Gestiune" - dialog opens
    - Fill form, submit - gestiune appears in table
    - Click "Editeaza" on row - dialog opens with data prefilled
    - Modify and save - changes appear in table
  </verify>
  <done>
    Gestiuni page shows list with DataTable. Create and edit work via dialog form.
  </done>
</task>

</tasks>

<verification>
1. API endpoints work:
   - GET /api/gestiuni returns list
   - POST /api/gestiuni creates new gestiune
   - PUT /api/gestiuni/:id updates gestiune
2. UI works:
   - Gestiuni page shows table with all gestiuni
   - Create dialog opens and creates new gestiune
   - Edit dialog opens with prefilled data and updates gestiune
3. Validation works:
   - Empty cod shows error: "Cod obligatoriu"
   - Empty denumire shows error: "Denumire obligatorie"
4. No TypeScript errors: both server and client lint pass
</verification>

<success_criteria>
- User can view list of gestiuni in a sortable table
- User can create a new gestiune with cod, denumire, responsabil, activ
- User can edit an existing gestiune
- Form validation shows Romanian error messages for required fields
- NOM-01 requirement is complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-nomenclatoare/02-02-SUMMARY.md`
</output>

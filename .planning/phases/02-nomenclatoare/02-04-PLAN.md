---
phase: 02-nomenclatoare
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - packages/server/src/routes/locuri.ts
  - packages/server/src/index.ts
  - packages/client/src/pages/Locuri.tsx
  - packages/client/src/components/nomenclatoare/LocuriForm.tsx
autonomous: true

must_haves:
  truths:
    - "User can see list of locuri de folosinta in a table"
    - "User can filter locuri by gestiune"
    - "User can create loc de folosinta within a specific gestiune"
    - "User can edit an existing loc de folosinta"
    - "Form shows gestiune selector as dropdown populated from API"
  artifacts:
    - path: "packages/server/src/routes/locuri.ts"
      provides: "Locuri Folosinta CRUD API with gestiune filter"
      exports: ["locuriRoutes"]
    - path: "packages/client/src/pages/Locuri.tsx"
      provides: "Locuri list with gestiune filter"
      min_lines: 90
    - path: "packages/client/src/components/nomenclatoare/LocuriForm.tsx"
      provides: "Create/Edit loc dialog with gestiune select"
      min_lines: 80
  key_links:
    - from: "packages/client/src/components/nomenclatoare/LocuriForm.tsx"
      to: "/api/gestiuni"
      via: "fetch for dropdown options"
      pattern: "api\\.get.*gestiuni"
    - from: "packages/server/src/routes/locuri.ts"
      to: "packages/server/src/db/schema.ts"
      via: "Drizzle query with join"
      pattern: "leftJoin.*gestiuni|with.*gestiune"
---

<objective>
Implement CRUD for Locuri de Folosinta (NOM-02) with dependent gestiune selector.

Purpose: Locuri are locations within gestiuni - the form must have a gestiune dropdown, and the list can filter by gestiune. This pattern will be reused in MijloaceFixe registration.
Output: Working locuri management with gestiune dependency.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-nomenclatoare/02-RESEARCH.md
@.planning/phases/02-nomenclatoare/02-01-SUMMARY.md
@.planning/phases/02-nomenclatoare/02-02-SUMMARY.md

@packages/server/src/db/schema.ts
@packages/server/src/validation/schemas.ts
@packages/server/src/routes/gestiuni.ts
@packages/client/src/pages/Gestiuni.tsx
@packages/client/src/components/nomenclatoare/GestiuniForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Locuri Folosinta API routes</name>
  <files>
    packages/server/src/routes/locuri.ts
    packages/server/src/index.ts
  </files>
  <action>
    1. Create packages/server/src/routes/locuri.ts:

       GET /
       - Accept query param: ?gestiuneId= (optional filter)
       - If gestiuneId provided: filter by gestiune_id
       - Include gestiune data in response (join or with)
       - Return ApiResponse<LocFolosinta[]>

       GET /:id
       - Return single loc with gestiune data
       - 404 if not found

       POST /
       - Validate body with insertLocFolosintaSchema (includes gestiuneId)
       - Verify gestiuneId exists (return 400 if not)
       - Insert and return created loc with gestiune

       PUT /:id
       - Update loc by id
       - Can change gestiuneId (validate it exists)
       - Return updated loc with gestiune

       Example using Drizzle relations:
       ```typescript
       import { Hono } from "hono";
       import { zValidator } from "@hono/zod-validator";
       import { eq } from "drizzle-orm";
       import { db } from "../db";
       import { locuriUilizare, gestiuni } from "../db/schema";
       import { insertLocFolosintaSchema } from "../validation/schemas";
       import type { ApiResponse, LocFolosinta } from "shared";

       export const locuriRoutes = new Hono();

       locuriRoutes.get("/", async (c) => {
         const gestiuneId = c.req.query("gestiuneId");

         const query = db.select({
           id: locuriUilizare.id,
           gestiuneId: locuriUilizare.gestiuneId,
           cod: locuriUilizare.cod,
           denumire: locuriUilizare.denumire,
           activ: locuriUilizare.activ,
           gestiune: {
             id: gestiuni.id,
             cod: gestiuni.cod,
             denumire: gestiuni.denumire,
           },
         })
         .from(locuriUilizare)
         .leftJoin(gestiuni, eq(locuriUilizare.gestiuneId, gestiuni.id));

         if (gestiuneId) {
           query.where(eq(locuriUilizare.gestiuneId, parseInt(gestiuneId)));
         }

         const result = await query.orderBy(locuriUilizare.cod);
         return c.json<ApiResponse<LocFolosinta[]>>({ success: true, data: result });
       });

       locuriRoutes.post("/",
         zValidator("json", insertLocFolosintaSchema),
         async (c) => {
           const data = c.req.valid("json");

           // Verify gestiune exists
           const [gestiune] = await db.select().from(gestiuni).where(eq(gestiuni.id, data.gestiuneId));
           if (!gestiune) {
             return c.json<ApiResponse>({ success: false, message: "Gestiunea nu exista" }, 400);
           }

           const [{ id }] = await db.insert(locuriUilizare).values(data).$returningId();
           // Fetch with join...
         }
       );
       ```

    2. Update packages/server/src/index.ts:
       - Import locuriRoutes
       - Mount at /api/locuri
  </action>
  <verify>
    - `bun run --cwd packages/server lint` passes
    - `curl http://localhost:3000/api/locuri` returns empty array
    - First create a gestiune (if not exists): `curl -X POST http://localhost:3000/api/gestiuni -H "Content-Type: application/json" -d '{"cod":"G001","denumire":"Gestiune Test"}'`
    - Note the gestiune id (e.g., 1)
    - Create loc: `curl -X POST http://localhost:3000/api/locuri -H "Content-Type: application/json" -d '{"gestiuneId":1,"cod":"L001","denumire":"Loc Test"}'`
    - Verify response includes gestiune object
    - Filter: `curl "http://localhost:3000/api/locuri?gestiuneId=1"` returns only locuri for that gestiune
  </verify>
  <done>
    Locuri API working with gestiune filtering and joins.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Locuri UI with gestiune dependent select</name>
  <files>
    packages/client/src/pages/Locuri.tsx
    packages/client/src/components/nomenclatoare/LocuriForm.tsx
  </files>
  <action>
    1. Create packages/client/src/components/nomenclatoare/LocuriForm.tsx:
       - Dialog form for create/edit
       - Fields: gestiuneId (required select), cod (required), denumire (required), activ
       - Fetch gestiuni on mount for the select dropdown
       - Use shadcn/ui Select component
       - Handle number type for gestiuneId correctly:
         - Value in Select must be string: value={field.value?.toString()}
         - Parse back on change: onValueChange={(v) => field.onChange(parseInt(v))}

       Example gestiune select:
       ```typescript
       const [gestiuni, setGestiuni] = useState<Gestiune[]>([]);

       useEffect(() => {
         api.get<Gestiune[]>("/gestiuni").then((res) => {
           if (res.success && res.data) setGestiuni(res.data.filter((g) => g.activ));
         });
       }, []);

       // In form:
       <FormField
         control={form.control}
         name="gestiuneId"
         render={({ field }) => (
           <FormItem>
             <FormLabel>Gestiune</FormLabel>
             <Select
               value={field.value?.toString()}
               onValueChange={(v) => field.onChange(parseInt(v))}
             >
               <FormControl>
                 <SelectTrigger>
                   <SelectValue placeholder="Selecteaza gestiunea" />
                 </SelectTrigger>
               </FormControl>
               <SelectContent>
                 {gestiuni.map((g) => (
                   <SelectItem key={g.id} value={g.id.toString()}>
                     {g.cod} - {g.denumire}
                   </SelectItem>
                 ))}
               </SelectContent>
             </Select>
             <FormMessage />
           </FormItem>
         )}
       />
       ```

    2. Update packages/client/src/pages/Locuri.tsx:
       - Filter dropdown at top to filter by gestiune
       - DataTable with columns: cod, denumire, gestiune.denumire, activ, actions
       - For gestiune column, use accessorFn: (row) => row.gestiune?.denumire
       - "Adauga Loc" and edit functionality

       Example filter:
       ```typescript
       const [gestiuni, setGestiuni] = useState<Gestiune[]>([]);
       const [selectedGestiune, setSelectedGestiune] = useState<string>("");

       useEffect(() => {
         api.get<Gestiune[]>("/gestiuni").then((res) => {
           if (res.success && res.data) setGestiuni(res.data);
         });
       }, []);

       const loadLocuri = async () => {
         const params = selectedGestiune ? `?gestiuneId=${selectedGestiune}` : "";
         const res = await api.get<LocFolosinta[]>(`/locuri${params}`);
         if (res.success && res.data) setLocuri(res.data);
       };

       // Filter UI:
       <Select value={selectedGestiune} onValueChange={setSelectedGestiune}>
         <SelectTrigger className="w-[250px]">
           <SelectValue placeholder="Toate gestiunile" />
         </SelectTrigger>
         <SelectContent>
           <SelectItem value="">Toate gestiunile</SelectItem>
           {gestiuni.map((g) => (
             <SelectItem key={g.id} value={g.id.toString()}>
               {g.cod} - {g.denumire}
             </SelectItem>
           ))}
         </SelectContent>
       </Select>
       ```
  </action>
  <verify>
    - `bun run --cwd packages/client lint` passes
    - Navigate to http://localhost:5173/locuri
    - Page shows table (empty initially)
    - Gestiune filter dropdown shows gestiuni from API
    - Click "Adauga Loc" - dialog opens with gestiune dropdown
    - Select gestiune, fill cod/denumire, submit - loc appears in table with gestiune name
    - Change filter - table filters by selected gestiune
    - Edit loc - dialog shows prefilled data including gestiune
  </verify>
  <done>
    Locuri page working with gestiune filter and dependent select in form.
  </done>
</task>

</tasks>

<verification>
1. API endpoints work:
   - GET /api/locuri returns list with gestiune data
   - GET /api/locuri?gestiuneId=X filters by gestiune
   - POST creates loc with gestiune validation
   - PUT updates loc
2. UI works:
   - Page shows locuri with gestiune column
   - Gestiune filter dropdown filters table
   - Create dialog has gestiune select populated from API
   - Edit dialog shows current gestiune selected
3. Dependent select pattern established for reuse in MijloaceFixe
</verification>

<success_criteria>
- NOM-02 complete: Locuri de Folosinta CRUD with gestiune dependency
- User can filter locuri by gestiune
- User can create loc within a specific gestiune (selected from dropdown)
- Gestiune dropdown only shows active gestiuni
- Pattern ready for MijloaceFixe (Phase 3)
</success_criteria>

<output>
After completion, create `.planning/phases/02-nomenclatoare/02-04-SUMMARY.md`
</output>

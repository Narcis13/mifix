---
phase: 02-nomenclatoare
plan: 05
type: execute
wave: 3
depends_on: ["02-01"]
files_modified:
  - packages/server/src/routes/conturi.ts
  - packages/server/src/index.ts
  - packages/client/src/pages/Conturi.tsx
  - packages/client/src/components/nomenclatoare/ConturiForm.tsx
autonomous: true

must_haves:
  truths:
    - "User can see list of conturi (plan de conturi) in a table"
    - "User can create cont with simbol, denumire, tip, amortizabil, contAmortizare"
    - "User can edit an existing cont"
    - "Form shows tip as dropdown (activ/pasiv/bifunctional)"
    - "ContAmortizare field only visible when amortizabil is checked"
  artifacts:
    - path: "packages/server/src/routes/conturi.ts"
      provides: "Conturi CRUD API"
      exports: ["conturiRoutes"]
    - path: "packages/client/src/pages/Conturi.tsx"
      provides: "Plan de Conturi list page"
      min_lines: 80
    - path: "packages/client/src/components/nomenclatoare/ConturiForm.tsx"
      provides: "Create/Edit cont dialog with conditional field"
      min_lines: 100
  key_links:
    - from: "packages/client/src/components/nomenclatoare/ConturiForm.tsx"
      to: "/api/conturi"
      via: "api.post/put"
      pattern: "api\\.(post|put).*conturi"
    - from: "packages/server/src/routes/conturi.ts"
      to: "packages/server/src/db/schema.ts"
      via: "Drizzle query"
      pattern: "db\\.(select|insert|update).*conturi"
---

<objective>
Implement CRUD for Plan de Conturi (NOM-04) with amortizare account linking.

Purpose: Conturi are used for accounting classification. Amortizabil conturi need a contAmortizare link. This conditional field pattern is common in accounting apps.
Output: Working plan de conturi management with conditional amortizare field.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-nomenclatoare/02-RESEARCH.md
@.planning/phases/02-nomenclatoare/02-01-SUMMARY.md
@.planning/phases/02-nomenclatoare/02-02-SUMMARY.md

@packages/server/src/db/schema.ts
@packages/server/src/validation/schemas.ts
@packages/server/src/routes/gestiuni.ts
@packages/client/src/pages/Gestiuni.tsx
@packages/client/src/components/nomenclatoare/GestiuniForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Conturi API routes</name>
  <files>
    packages/server/src/routes/conturi.ts
    packages/server/src/index.ts
  </files>
  <action>
    1. Create packages/server/src/routes/conturi.ts:

       GET /
       - Return all conturi ordered by simbol
       - Response: ApiResponse<Cont[]>

       GET /:id
       - Return single cont by id
       - 404 if not found

       POST /
       - Validate body with insertContSchema
       - If amortizabil=true but contAmortizare empty, return 400 with error
       - If amortizabil=false, clear contAmortizare (set to null)
       - Insert and return created cont

       PUT /:id
       - Same validation as POST
       - Update cont by id
       - Return updated cont

       Example validation:
       ```typescript
       import { Hono } from "hono";
       import { zValidator } from "@hono/zod-validator";
       import { eq } from "drizzle-orm";
       import { db } from "../db";
       import { conturi } from "../db/schema";
       import { insertContSchema } from "../validation/schemas";
       import type { ApiResponse, Cont } from "shared";

       export const conturiRoutes = new Hono();

       conturiRoutes.post("/",
         zValidator("json", insertContSchema),
         async (c) => {
           const data = c.req.valid("json");

           // Validate contAmortizare requirement
           if (data.amortizabil && !data.contAmortizare) {
             return c.json<ApiResponse>({
               success: false,
               message: "Contul de amortizare este obligatoriu pentru conturile amortizabile",
             }, 400);
           }

           // Clear contAmortizare if not amortizabil
           const insertData = {
             ...data,
             contAmortizare: data.amortizabil ? data.contAmortizare : null,
           };

           const [{ id }] = await db.insert(conturi).values(insertData).$returningId();
           const [created] = await db.select().from(conturi).where(eq(conturi.id, id));
           return c.json<ApiResponse<Cont>>({ success: true, data: created }, 201);
         }
       );
       ```

    2. Update packages/server/src/index.ts:
       - Import conturiRoutes
       - Mount at /api/conturi
  </action>
  <verify>
    - `bun run --cwd packages/server lint` passes
    - `curl http://localhost:3000/api/conturi` returns empty array
    - Create non-amortizabil cont: `curl -X POST http://localhost:3000/api/conturi -H "Content-Type: application/json" -d '{"simbol":"101","denumire":"Capital social","tip":"pasiv","amortizabil":false}'`
    - Try amortizabil without contAmortizare - should return 400
    - Create amortizabil cont: `curl -X POST http://localhost:3000/api/conturi -H "Content-Type: application/json" -d '{"simbol":"2131","denumire":"Echipamente","tip":"activ","amortizabil":true,"contAmortizare":"2811"}'`
  </verify>
  <done>
    Conturi API working with amortizare validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Conturi UI with conditional amortizare field</name>
  <files>
    packages/client/src/pages/Conturi.tsx
    packages/client/src/components/nomenclatoare/ConturiForm.tsx
  </files>
  <action>
    1. Create packages/client/src/components/nomenclatoare/ConturiForm.tsx:
       - Dialog form for create/edit
       - Fields:
         - simbol (required text input)
         - denumire (required text input)
         - tip (required select: activ/pasiv/bifunctional)
         - amortizabil (checkbox)
         - contAmortizare (text input, only visible when amortizabil=true)
         - activ (checkbox)

       - Watch amortizabil field to show/hide contAmortizare:
         ```typescript
         const amortizabil = form.watch("amortizabil");

         // In JSX:
         {amortizabil && (
           <FormField
             control={form.control}
             name="contAmortizare"
             render={({ field }) => (
               <FormItem>
                 <FormLabel>Cont Amortizare</FormLabel>
                 <FormControl>
                   <Input placeholder="ex: 2811" {...field} value={field.value || ""} />
                 </FormControl>
                 <FormMessage />
               </FormItem>
             )}
           />
         )}
         ```

       - Form schema with conditional validation:
         ```typescript
         const formSchema = z.object({
           simbol: z.string().min(1, "Simbol obligatoriu").max(20),
           denumire: z.string().min(1, "Denumire obligatorie").max(300),
           tip: z.enum(["activ", "pasiv", "bifunctional"]),
           amortizabil: z.boolean().default(false),
           contAmortizare: z.string().max(20).optional().nullable(),
           activ: z.boolean().default(true),
         }).refine((data) => {
           if (data.amortizabil && !data.contAmortizare) return false;
           return true;
         }, {
           message: "Contul de amortizare este obligatoriu",
           path: ["contAmortizare"],
         });
         ```

    2. Update packages/client/src/pages/Conturi.tsx:
       - DataTable with columns: simbol, denumire, tip (display Romanian), amortizabil, contAmortizare, activ, actions
       - For tip display, map to Romanian: activ="Activ", pasiv="Pasiv", bifunctional="Bifunctional"
       - "Adauga Cont" button and edit functionality

       Column example:
       ```typescript
       {
         accessorKey: "tip",
         header: "Tip",
         cell: ({ row }) => {
           const tipLabels = { activ: "Activ", pasiv: "Pasiv", bifunctional: "Bifunctional" };
           return tipLabels[row.original.tip] || row.original.tip;
         },
       },
       {
         accessorKey: "amortizabil",
         header: "Amortizabil",
         cell: ({ row }) => row.original.amortizabil ? "Da" : "Nu",
       },
       ```
  </action>
  <verify>
    - `bun run --cwd packages/client lint` passes
    - Navigate to http://localhost:5173/conturi
    - Page shows table (empty initially)
    - Click "Adauga Cont" - dialog opens
    - Check amortizabil - contAmortizare field appears
    - Uncheck amortizabil - contAmortizare field hides
    - Submit amortizabil without contAmortizare - shows validation error
    - Submit amortizabil with contAmortizare - success
    - Cont appears in table with correct tip display
  </verify>
  <done>
    Conturi page working with conditional amortizare field.
  </done>
</task>

</tasks>

<verification>
1. API endpoints work:
   - GET /api/conturi returns list
   - POST validates amortizabil + contAmortizare dependency
   - PUT updates cont with same validation
2. UI works:
   - Page shows table with all columns
   - Tip column shows Romanian labels
   - Amortizabil checkbox toggles contAmortizare visibility
   - Validation prevents submit of amortizabil without contAmortizare
3. Conditional field pattern established for similar accounting forms
</verification>

<success_criteria>
- NOM-04 complete: Plan de Conturi CRUD with amortizare linking
- Tip dropdown shows activ/pasiv/bifunctional
- ContAmortizare only visible when amortizabil checked
- Validation enforces contAmortizare when amortizabil=true
- All nomenclatoare requirements (NOM-01 to NOM-05) complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-nomenclatoare/02-05-SUMMARY.md`
</output>

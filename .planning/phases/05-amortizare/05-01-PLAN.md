---
phase: 05-amortizare
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/db/schema.ts
  - packages/server/src/validation/amortizari-schemas.ts
  - packages/server/src/routes/amortizari.ts
  - packages/server/src/index.ts
  - packages/shared/src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Batch depreciation endpoint calculates correct monthly depreciation for all eligible assets"
    - "Final month depreciation equals remaining value (no over-depreciation)"
    - "Duplicate depreciation entries are prevented by unique constraint"
    - "Asset valoareAmortizata and valoareRamasa update atomically with depreciation record"
  artifacts:
    - path: "packages/server/src/routes/amortizari.ts"
      provides: "Depreciation API endpoints (generate, history, summary, verification)"
      exports: ["amortizariRoutes"]
    - path: "packages/server/src/validation/amortizari-schemas.ts"
      provides: "Zod validation schemas for depreciation operations"
      exports: ["genereazaAmortizareSchema"]
  key_links:
    - from: "packages/server/src/routes/amortizari.ts"
      to: "packages/server/src/db/schema.ts"
      via: "Drizzle queries"
      pattern: "db\\.transaction|amortizari|mijloaceFixe"
    - from: "packages/server/src/routes/amortizari.ts"
      to: "shared/money.ts"
      via: "Money class import"
      pattern: "Money\\.fromDb|calculateMonthlyDepreciation"
---

<objective>
Create the complete Amortizare API: batch depreciation generation endpoint with atomic transactions, per-asset history endpoint, monthly summary endpoint, and verification endpoint to check processed months.

Purpose: Enables accountants to generate monthly depreciation for all active assets with a single action, maintaining decimal precision and preventing over-depreciation.

Output: Fully functional API routes for depreciation management at /api/amortizari/*
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-amortizare/05-RESEARCH.md

Reference existing patterns:
@packages/server/src/routes/operatiuni.ts (atomic transaction pattern)
@packages/server/src/db/schema.ts (amortizari table already exists)
@packages/shared/src/money.ts (Money class with calculateMonthlyDepreciation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unique constraint to amortizari table</name>
  <files>packages/server/src/db/schema.ts</files>
  <action>
Add unique composite index on (mijlocFixId, an, luna) to prevent duplicate depreciation entries.

In the amortizari table definition, add to the table function alongside the existing index:
```typescript
uniqueIndex("uniq_amortizari_mijloc_fix_an_luna").on(table.mijlocFixId, table.an, table.luna),
```

Import `uniqueIndex` from "drizzle-orm/mysql-core" at the top of the file.

This database-level constraint ensures that even with race conditions in batch generation, duplicate entries cannot be created.
  </action>
  <verify>
Run `bun run db:push` from packages/server to apply the schema change. Verify no errors and the unique index is created.
  </verify>
  <done>
Schema has unique constraint on (mijlocFixId, an, luna) preventing duplicate depreciation entries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Amortizari validation schemas + shared types</name>
  <files>packages/server/src/validation/amortizari-schemas.ts, packages/shared/src/types/index.ts</files>
  <action>
**Create packages/server/src/validation/amortizari-schemas.ts:**

```typescript
import { z } from "zod";

// POST /amortizari/genereaza request body
export const genereazaAmortizareSchema = z.object({
  an: z.number().int().min(2020).max(2100),
  luna: z.number().int().min(1).max(12),
});

export type GenereazaAmortizareInput = z.infer<typeof genereazaAmortizareSchema>;
```

**Update packages/shared/src/types/index.ts:**

The Amortizare interface already exists but needs adjustment to match the actual schema. Update it to:

```typescript
export interface Amortizare {
  id: number;
  mijlocFixId: number;
  mijlocFix?: MijlocFix;
  an: number;
  luna: number;
  valoareLunara: string;
  valoareCumulata: string;
  valoareRamasa: string;
  valoareInventar: string;
  durataRamasa: number;
  calculat: boolean;
  dataCalcul?: string;
  createdAt: string;
}

// Batch generation response
export interface GenereazaAmortizareResult {
  processed: number;
  skipped: number;
  totalEligible: number;
}

// Monthly summary for AMO-05
export interface AmortizareSumar {
  an: number;
  luna: number;
  totalLunar: string;
  numarActive: number;
}

// Verification response
export interface AmortizareVerificare {
  luna: number;
  procesat: boolean;
  numarActive: number;
}
```
  </action>
  <verify>
Run `bun tsc --noEmit` from project root. No TypeScript errors.
  </verify>
  <done>
Zod schemas for batch generation, shared types for Amortizare responses all defined.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Amortizari API routes with batch generation</name>
  <files>packages/server/src/routes/amortizari.ts, packages/server/src/index.ts</files>
  <action>
**Create packages/server/src/routes/amortizari.ts:**

```typescript
import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { eq, and, desc, gt, sql } from "drizzle-orm";
import { db } from "../db";
import { mijloaceFixe, amortizari } from "../db/schema";
import { Money } from "shared";
import type { ApiResponse, Amortizare, GenereazaAmortizareResult, AmortizareSumar, AmortizareVerificare } from "shared";
import { genereazaAmortizareSchema } from "../validation/amortizari-schemas";

export const amortizariRoutes = new Hono();

// ============================================================================
// POST /genereaza - Batch generate depreciation (AMO-01, AMO-02, AMO-03, AMO-06)
// ============================================================================
amortizariRoutes.post(
  "/genereaza",
  zValidator("json", genereazaAmortizareSchema, (result, c) => {
    if (!result.success) {
      const errors: Record<string, string[]> = {};
      result.error.issues.forEach((issue) => {
        const path = issue.path.join(".");
        if (!errors[path]) errors[path] = [];
        errors[path].push(issue.message);
      });
      return c.json<ApiResponse>({ success: false, message: "Validare esuata", errors }, 400);
    }
  }),
  async (c) => {
    const { an, luna } = c.req.valid("json");

    try {
      const result = await db.transaction(async (tx) => {
        // 1. Get all eligible assets: active, depreciable, has remaining value
        const assets = await tx
          .select()
          .from(mijloaceFixe)
          .where(
            and(
              eq(mijloaceFixe.stare, "activ"),
              eq(mijloaceFixe.eAmortizabil, true),
              gt(mijloaceFixe.valoareRamasa, "0")
            )
          );

        const totalEligible = assets.length;

        // 2. Check for existing entries for this month (prevent duplicates)
        const existing = await tx
          .select({ mijlocFixId: amortizari.mijlocFixId })
          .from(amortizari)
          .where(and(eq(amortizari.an, an), eq(amortizari.luna, luna)));
        const existingIds = new Set(existing.map((e) => e.mijlocFixId));

        // 3. Calculate and insert depreciation for each eligible asset
        let processed = 0;
        let skipped = existingIds.size;

        for (const asset of assets) {
          if (existingIds.has(asset.id)) continue; // Skip already processed

          const valoareInventar = Money.fromDb(asset.valoareInventar);
          const valoareAmortizataCurenta = Money.fromDb(asset.valoareAmortizata);
          const valoareRamasaCurenta = Money.fromDb(asset.valoareRamasa);

          // AMO-01: Calculate monthly depreciation (linear method)
          const cotaLunara = Money.calculateMonthlyDepreciation(valoareInventar, asset.durataNormala);

          // AMO-06: Final month protection - don't exceed remaining value
          const amortizareLunara = cotaLunara.greaterThan(valoareRamasaCurenta)
            ? valoareRamasaCurenta // Last month: depreciate only what remains
            : cotaLunara;

          // AMO-03: Calculate new cumulative and remaining values
          const nouaValoareAmortizata = valoareAmortizataCurenta.plus(amortizareLunara);
          const nouaValoareRamasa = valoareRamasaCurenta.minus(amortizareLunara);
          const nouaDurataRamasa = Math.max(0, asset.durataRamasa - 1);

          // Insert depreciation record
          await tx.insert(amortizari).values({
            mijlocFixId: asset.id,
            an,
            luna,
            valoareLunara: amortizareLunara.toDbString(),
            valoareCumulata: nouaValoareAmortizata.toDbString(),
            valoareRamasa: nouaValoareRamasa.toDbString(),
            valoareInventar: asset.valoareInventar,
            durataRamasa: nouaDurataRamasa,
            calculat: true,
            dataCalcul: new Date(),
          });

          // Update asset values
          await tx
            .update(mijloaceFixe)
            .set({
              valoareAmortizata: nouaValoareAmortizata.toDbString(),
              valoareRamasa: nouaValoareRamasa.toDbString(),
              durataRamasa: nouaDurataRamasa,
            })
            .where(eq(mijloaceFixe.id, asset.id));

          processed++;
        }

        return { processed, skipped, totalEligible };
      });

      return c.json<ApiResponse<GenereazaAmortizareResult>>({ success: true, data: result });
    } catch (error) {
      console.error("Generare amortizare error:", error);

      // Check for duplicate key error (race condition protection)
      const message = error instanceof Error ? error.message : "";
      if (message.includes("Duplicate entry")) {
        return c.json<ApiResponse>({
          success: false,
          message: "Amortizarea pentru aceasta luna a fost deja generata"
        }, 409);
      }

      return c.json<ApiResponse>({
        success: false,
        message: "Eroare la generarea amortizarii"
      }, 500);
    }
  }
);

// ============================================================================
// GET /istoric/:mijlocFixId - Per-asset depreciation history (AMO-04)
// ============================================================================
amortizariRoutes.get("/istoric/:mijlocFixId", async (c) => {
  const mijlocFixId = parseInt(c.req.param("mijlocFixId"));

  if (isNaN(mijlocFixId)) {
    return c.json<ApiResponse>({ success: false, message: "ID invalid" }, 400);
  }

  try {
    const result = await db
      .select()
      .from(amortizari)
      .where(eq(amortizari.mijlocFixId, mijlocFixId))
      .orderBy(desc(amortizari.an), desc(amortizari.luna));

    const items: Amortizare[] = result.map((row) => ({
      id: row.id,
      mijlocFixId: row.mijlocFixId,
      an: row.an,
      luna: row.luna,
      valoareLunara: row.valoareLunara,
      valoareCumulata: row.valoareCumulata,
      valoareRamasa: row.valoareRamasa,
      valoareInventar: row.valoareInventar,
      durataRamasa: row.durataRamasa,
      calculat: row.calculat ?? false,
      dataCalcul: row.dataCalcul?.toISOString(),
      createdAt: row.createdAt.toISOString(),
    }));

    return c.json<ApiResponse<Amortizare[]>>({ success: true, data: items });
  } catch (error) {
    console.error("Get istoric amortizare error:", error);
    return c.json<ApiResponse>({ success: false, message: "Eroare la obtinerea istoricului" }, 500);
  }
});

// ============================================================================
// GET /sumar - Monthly/yearly summary across all assets (AMO-05)
// ============================================================================
amortizariRoutes.get("/sumar", async (c) => {
  const anParam = c.req.query("an");
  const an = anParam ? parseInt(anParam) : undefined;

  try {
    let query = db
      .select({
        an: amortizari.an,
        luna: amortizari.luna,
        totalLunar: sql<string>`cast(sum(${amortizari.valoareLunara}) as decimal(15,2))`,
        numarActive: sql<number>`count(distinct ${amortizari.mijlocFixId})`,
      })
      .from(amortizari)
      .groupBy(amortizari.an, amortizari.luna)
      .orderBy(desc(amortizari.an), desc(amortizari.luna));

    // Filter by year if provided
    const result = an
      ? await query.where(eq(amortizari.an, an))
      : await query;

    const items: AmortizareSumar[] = result.map((row) => ({
      an: row.an,
      luna: row.luna,
      totalLunar: row.totalLunar ?? "0.00",
      numarActive: Number(row.numarActive) || 0,
    }));

    return c.json<ApiResponse<AmortizareSumar[]>>({ success: true, data: items });
  } catch (error) {
    console.error("Get sumar amortizare error:", error);
    return c.json<ApiResponse>({ success: false, message: "Eroare la obtinerea sumarului" }, 500);
  }
});

// ============================================================================
// GET /verificare - Check which months are already processed
// ============================================================================
amortizariRoutes.get("/verificare", async (c) => {
  const anParam = c.req.query("an");
  const an = anParam ? parseInt(anParam) : new Date().getFullYear();

  try {
    // Get all months with depreciation for this year
    const result = await db
      .select({
        luna: amortizari.luna,
        numarActive: sql<number>`count(distinct ${amortizari.mijlocFixId})`,
      })
      .from(amortizari)
      .where(eq(amortizari.an, an))
      .groupBy(amortizari.luna)
      .orderBy(amortizari.luna);

    // Build response for all 12 months
    const processedMonths = new Map(result.map((r) => [r.luna, Number(r.numarActive)]));

    const items: AmortizareVerificare[] = [];
    for (let luna = 1; luna <= 12; luna++) {
      items.push({
        luna,
        procesat: processedMonths.has(luna),
        numarActive: processedMonths.get(luna) || 0,
      });
    }

    return c.json<ApiResponse<AmortizareVerificare[]>>({ success: true, data: items });
  } catch (error) {
    console.error("Get verificare amortizare error:", error);
    return c.json<ApiResponse>({ success: false, message: "Eroare la verificare" }, 500);
  }
});
```

**Update packages/server/src/index.ts:**

Add import and route registration alongside existing routes:
```typescript
import { amortizariRoutes } from "./routes/amortizari";
// ... in the route registration section:
app.route("/api/amortizari", amortizariRoutes);
```
  </action>
  <verify>
1. Run `bun dev` from packages/server
2. Test batch generation: `curl -X POST http://localhost:3000/api/amortizari/genereaza -H "Content-Type: application/json" -d '{"an": 2026, "luna": 1}'`
3. Test history: `curl http://localhost:3000/api/amortizari/istoric/1`
4. Test summary: `curl http://localhost:3000/api/amortizari/sumar?an=2026`
5. Test verification: `curl http://localhost:3000/api/amortizari/verificare?an=2026`
All endpoints return successful JSON responses.
  </verify>
  <done>
Four API endpoints functional: POST /genereaza (batch), GET /istoric/:id, GET /sumar, GET /verificare.
Batch generation uses atomic transactions, Money class for precision, handles final month correctly.
  </done>
</task>

</tasks>

<verification>
1. Schema has unique constraint preventing duplicate (mijlocFixId, an, luna) entries
2. POST /api/amortizari/genereaza returns processed/skipped counts
3. Running same generation twice for same month returns 0 processed (all skipped)
4. GET /api/amortizari/istoric/:id returns chronological depreciation history
5. GET /api/amortizari/sumar returns monthly totals across all assets
6. GET /api/amortizari/verificare shows which months are processed
7. All monetary calculations use Money class (no floating point)
8. TypeScript compiles without errors
</verification>

<success_criteria>
- Batch depreciation endpoint creates records for all eligible active, amortizable assets with remaining value
- Final month depreciation equals remaining value (AMO-06)
- Asset valoareAmortizata and valoareRamasa update atomically with each depreciation record (AMO-03)
- Duplicate entries prevented by unique constraint
- Per-asset history available via /istoric endpoint (AMO-04)
- Summary by month/year available via /sumar endpoint (AMO-05)
- Verification endpoint shows processed months
</success_criteria>

<output>
After completion, create `.planning/phases/05-amortizare/05-01-SUMMARY.md`
</output>

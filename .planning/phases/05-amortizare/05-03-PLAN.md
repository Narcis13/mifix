---
phase: 05-amortizare
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - packages/client/src/pages/Amortizare.tsx
  - packages/client/src/components/amortizare/GenereazaAmortizareDialog.tsx
  - packages/client/src/components/amortizare/AmortizariSummary.tsx
  - packages/client/src/lib/api.ts
  - packages/client/src/App.tsx
  - packages/client/src/main.tsx
autonomous: true

must_haves:
  truths:
    - "User can run monthly depreciation calculation for all active assets"
    - "User can view depreciation summary by month/year across all assets"
    - "User sees which months are already processed before generating"
    - "Success feedback shows how many assets were processed"
  artifacts:
    - path: "packages/client/src/pages/Amortizare.tsx"
      provides: "Main depreciation management page"
      min_lines: 80
    - path: "packages/client/src/components/amortizare/GenereazaAmortizareDialog.tsx"
      provides: "Month/year selection dialog for batch generation"
      min_lines: 100
    - path: "packages/client/src/components/amortizare/AmortizariSummary.tsx"
      provides: "Summary cards showing monthly/yearly totals"
      min_lines: 60
  key_links:
    - from: "packages/client/src/pages/Amortizare.tsx"
      to: "/api/amortizari/sumar"
      via: "fetch call"
      pattern: "api/amortizari/sumar"
    - from: "packages/client/src/components/amortizare/GenereazaAmortizareDialog.tsx"
      to: "/api/amortizari/genereaza"
      via: "POST fetch"
      pattern: "api/amortizari/genereaza"
---

<objective>
Create the main Amortizare page with batch generation dialog and summary view (AMO-02, AMO-05).

Purpose: Provides accountants with a central location to generate monthly depreciation for all assets and view summary reports.

Output: Amortizare page with generation dialog showing processed months and summary table displaying monthly totals.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-amortizare/05-01-SUMMARY.md

Reference existing patterns:
@packages/client/src/components/operatiuni/CasareDialog.tsx (dialog form pattern)
@packages/client/src/pages/Gestiuni.tsx (page with dialog trigger)
@packages/client/src/App.tsx (navigation and routing)
@packages/shared/src/types/index.ts (AmortizareSumar, GenereazaAmortizareResult types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API client functions for depreciation management</name>
  <files>packages/client/src/lib/api.ts</files>
  <action>
Add functions for batch generation, summary, and verification:

```typescript
import type { GenereazaAmortizareResult, AmortizareSumar, AmortizareVerificare } from "shared";

// Generate depreciation for a specific month/year
export async function genereazaAmortizare(an: number, luna: number): Promise<GenereazaAmortizareResult> {
  const response = await fetch("/api/amortizari/genereaza", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ an, luna }),
  });
  const data: ApiResponse<GenereazaAmortizareResult> = await response.json();
  if (!data.success) {
    throw new Error(data.message || "Failed to generate depreciation");
  }
  return data.data!;
}

// Get depreciation summary by month/year
export async function getAmortizariSumar(an?: number): Promise<AmortizareSumar[]> {
  const url = an ? `/api/amortizari/sumar?an=${an}` : "/api/amortizari/sumar";
  const response = await fetch(url);
  const data: ApiResponse<AmortizareSumar[]> = await response.json();
  if (!data.success) {
    throw new Error(data.message || "Failed to fetch summary");
  }
  return data.data || [];
}

// Get verification of which months are processed
export async function getAmortizariVerificare(an: number): Promise<AmortizareVerificare[]> {
  const response = await fetch(`/api/amortizari/verificare?an=${an}`);
  const data: ApiResponse<AmortizareVerificare[]> = await response.json();
  if (!data.success) {
    throw new Error(data.message || "Failed to fetch verification");
  }
  return data.data || [];
}
```

Import the types from shared at the top of the file.
  </action>
  <verify>
TypeScript compiles without errors.
  </verify>
  <done>
API client functions added for genereazaAmortizare, getAmortizariSumar, getAmortizariVerificare.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GenereazaAmortizareDialog component</name>
  <files>packages/client/src/components/amortizare/GenereazaAmortizareDialog.tsx</files>
  <action>
Create a dialog for selecting month/year and triggering batch generation:

```typescript
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { genereazaAmortizare, getAmortizariVerificare } from "@/lib/api";
import type { AmortizareVerificare } from "shared";
import { toast } from "sonner";
import { Calculator, CheckCircle2, AlertCircle } from "lucide-react";

interface GenereazaAmortizareDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

const MONTH_NAMES = [
  "Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie",
  "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"
];

const currentYear = new Date().getFullYear();
const currentMonth = new Date().getMonth() + 1;

const formSchema = z.object({
  an: z.string().min(1, "Selectati anul"),
  luna: z.string().min(1, "Selectati luna"),
});

type FormValues = z.infer<typeof formSchema>;

export function GenereazaAmortizareDialog({
  open,
  onOpenChange,
  onSuccess,
}: GenereazaAmortizareDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [verificare, setVerificare] = useState<AmortizareVerificare[]>([]);
  const [loadingVerificare, setLoadingVerificare] = useState(false);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      an: currentYear.toString(),
      luna: currentMonth.toString(),
    },
  });

  const selectedAn = form.watch("an");
  const selectedLuna = form.watch("luna");

  // Load verification data when year changes
  useEffect(() => {
    if (!open || !selectedAn) return;

    async function loadVerificare() {
      try {
        setLoadingVerificare(true);
        const data = await getAmortizariVerificare(parseInt(selectedAn));
        setVerificare(data);
      } catch (err) {
        console.error("Failed to load verification:", err);
      } finally {
        setLoadingVerificare(false);
      }
    }
    loadVerificare();
  }, [open, selectedAn]);

  // Check if selected month is already processed
  const selectedMonthVerificare = verificare.find(
    (v) => v.luna === parseInt(selectedLuna || "0")
  );
  const isAlreadyProcessed = selectedMonthVerificare?.procesat ?? false;

  async function onSubmit(values: FormValues) {
    setIsSubmitting(true);
    setError(null);

    try {
      const result = await genereazaAmortizare(
        parseInt(values.an),
        parseInt(values.luna)
      );

      if (result.processed === 0 && result.skipped > 0) {
        toast.info("Amortizarea pentru aceasta luna a fost deja generata", {
          description: `${result.skipped} active au fost sarite.`,
        });
      } else if (result.processed > 0) {
        toast.success("Amortizare generata cu succes", {
          description: `${result.processed} active procesate, ${result.skipped} sarite.`,
        });
      } else {
        toast.info("Nu exista active eligibile pentru amortizare", {
          description: "Verificati ca exista active active si amortizabile.",
        });
      }

      onSuccess();
      onOpenChange(false);
      form.reset();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Eroare la generare");
    } finally {
      setIsSubmitting(false);
    }
  }

  // Reset form when dialog opens
  useEffect(() => {
    if (open) {
      form.reset({
        an: currentYear.toString(),
        luna: currentMonth.toString(),
      });
      setError(null);
    }
  }, [open, form]);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Calculator className="h-5 w-5" />
            Genereaza Amortizare Lunara
          </DialogTitle>
          <DialogDescription>
            Selectati luna si anul pentru care doriti sa generati amortizarea
            pentru toate mijloacele fixe active.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}

            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="an"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>An</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Selectati anul" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {[currentYear - 1, currentYear, currentYear + 1].map(
                          (year) => (
                            <SelectItem key={year} value={year.toString()}>
                              {year}
                            </SelectItem>
                          )
                        )}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="luna"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Luna</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Selectati luna" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {MONTH_NAMES.map((name, index) => {
                          const monthNum = index + 1;
                          const monthVerif = verificare.find(
                            (v) => v.luna === monthNum
                          );
                          const processed = monthVerif?.procesat ?? false;

                          return (
                            <SelectItem key={monthNum} value={monthNum.toString()}>
                              <span className="flex items-center gap-2">
                                {name}
                                {processed && (
                                  <CheckCircle2 className="h-3 w-3 text-green-500" />
                                )}
                              </span>
                            </SelectItem>
                          );
                        })}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {isAlreadyProcessed && (
              <Alert>
                <CheckCircle2 className="h-4 w-4 text-green-500" />
                <AlertDescription>
                  Amortizarea pentru {MONTH_NAMES[parseInt(selectedLuna) - 1]}{" "}
                  {selectedAn} a fost deja generata pentru{" "}
                  {selectedMonthVerificare?.numarActive} active.
                </AlertDescription>
              </Alert>
            )}

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
              >
                Anuleaza
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? "Se genereaza..." : "Genereaza"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>
TypeScript compiles without errors. Component imports resolve correctly.
  </verify>
  <done>
GenereazaAmortizareDialog component created with month/year selection, verification status indicators, and batch generation trigger.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AmortizariSummary component and Amortizare page</name>
  <files>packages/client/src/components/amortizare/AmortizariSummary.tsx, packages/client/src/pages/Amortizare.tsx, packages/client/src/App.tsx, packages/client/src/main.tsx</files>
  <action>
**Create packages/client/src/components/amortizare/AmortizariSummary.tsx:**

```typescript
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import type { AmortizareSumar } from "shared";

interface AmortizariSummaryProps {
  data: AmortizareSumar[];
  isLoading: boolean;
}

const MONTH_NAMES = [
  "Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie",
  "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"
];

function formatMoney(value: string): string {
  const num = parseFloat(value);
  return num.toLocaleString("ro-RO", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

export function AmortizariSummary({ data, isLoading }: AmortizariSummaryProps) {
  if (isLoading) {
    return <p className="text-muted-foreground text-sm py-4">Se incarca...</p>;
  }

  if (data.length === 0) {
    return (
      <p className="text-muted-foreground text-sm py-4 text-center">
        Nu exista inregistrari de amortizare.
      </p>
    );
  }

  // Calculate yearly totals
  const yearlyTotals = data.reduce((acc, item) => {
    if (!acc[item.an]) {
      acc[item.an] = { total: 0, count: 0 };
    }
    acc[item.an].total += parseFloat(item.totalLunar);
    acc[item.an].count += item.numarActive;
    return acc;
  }, {} as Record<number, { total: number; count: number }>);

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Perioada</TableHead>
          <TableHead className="text-right">Total Amortizare</TableHead>
          <TableHead className="text-right">Nr. Active</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {data.map((item) => (
          <TableRow key={`${item.an}-${item.luna}`}>
            <TableCell className="font-medium">
              {MONTH_NAMES[item.luna - 1]} {item.an}
            </TableCell>
            <TableCell className="text-right font-mono">
              {formatMoney(item.totalLunar)} RON
            </TableCell>
            <TableCell className="text-right">{item.numarActive}</TableCell>
          </TableRow>
        ))}
        {/* Show yearly totals as footer rows */}
        {Object.entries(yearlyTotals)
          .sort(([a], [b]) => parseInt(b) - parseInt(a))
          .map(([year, totals]) => (
            <TableRow key={`total-${year}`} className="bg-muted/50 font-semibold">
              <TableCell>Total {year}</TableCell>
              <TableCell className="text-right font-mono">
                {formatMoney(totals.total.toFixed(2))} RON
              </TableCell>
              <TableCell className="text-right">-</TableCell>
            </TableRow>
          ))}
      </TableBody>
    </Table>
  );
}
```

**Create packages/client/src/pages/Amortizare.tsx:**

```typescript
import { useState, useEffect, useCallback } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { GenereazaAmortizareDialog } from "@/components/amortizare/GenereazaAmortizareDialog";
import { AmortizariSummary } from "@/components/amortizare/AmortizariSummary";
import { getAmortizariSumar } from "@/lib/api";
import type { AmortizareSumar } from "shared";
import { Calculator, Plus, TrendingDown } from "lucide-react";

const currentYear = new Date().getFullYear();

export default function Amortizare() {
  const [summary, setSummary] = useState<AmortizareSumar[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedYear, setSelectedYear] = useState<string>("all");
  const [dialogOpen, setDialogOpen] = useState(false);

  const loadSummary = useCallback(async () => {
    try {
      setIsLoading(true);
      const year = selectedYear !== "all" ? parseInt(selectedYear) : undefined;
      const data = await getAmortizariSumar(year);
      setSummary(data);
    } catch (err) {
      console.error("Failed to load summary:", err);
    } finally {
      setIsLoading(false);
    }
  }, [selectedYear]);

  useEffect(() => {
    loadSummary();
  }, [loadSummary]);

  // Calculate overall stats
  const totalAmortizare = summary.reduce(
    (sum, item) => sum + parseFloat(item.totalLunar),
    0
  );
  const totalLuni = summary.length;
  const avgPerMonth = totalLuni > 0 ? totalAmortizare / totalLuni : 0;

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <TrendingDown className="h-6 w-6" />
            Amortizare
          </h1>
          <p className="text-muted-foreground">
            Generare si vizualizare amortizare lunara
          </p>
        </div>
        <Button onClick={() => setDialogOpen(true)}>
          <Plus className="mr-2 h-4 w-4" />
          Genereaza Amortizare
        </Button>
      </div>

      {/* Stats Cards */}
      <div className="grid gap-4 md:grid-cols-3">
        <Card>
          <CardHeader className="pb-2">
            <CardDescription>Total Amortizare</CardDescription>
            <CardTitle className="text-2xl font-mono">
              {totalAmortizare.toLocaleString("ro-RO", {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
              })}{" "}
              RON
            </CardTitle>
          </CardHeader>
        </Card>
        <Card>
          <CardHeader className="pb-2">
            <CardDescription>Luni Procesate</CardDescription>
            <CardTitle className="text-2xl">{totalLuni}</CardTitle>
          </CardHeader>
        </Card>
        <Card>
          <CardHeader className="pb-2">
            <CardDescription>Media Lunara</CardDescription>
            <CardTitle className="text-2xl font-mono">
              {avgPerMonth.toLocaleString("ro-RO", {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
              })}{" "}
              RON
            </CardTitle>
          </CardHeader>
        </Card>
      </div>

      {/* Summary Table */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center gap-2">
                <Calculator className="h-5 w-5" />
                Sumar Amortizari
              </CardTitle>
              <CardDescription>
                Amortizarea totala pe luna pentru toate mijloacele fixe
              </CardDescription>
            </div>
            <Select value={selectedYear} onValueChange={setSelectedYear}>
              <SelectTrigger className="w-[150px]">
                <SelectValue placeholder="Filtreaza an" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Toti anii</SelectItem>
                {[currentYear - 1, currentYear, currentYear + 1].map((year) => (
                  <SelectItem key={year} value={year.toString()}>
                    {year}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </CardHeader>
        <CardContent>
          <AmortizariSummary data={summary} isLoading={isLoading} />
        </CardContent>
      </Card>

      {/* Generation Dialog */}
      <GenereazaAmortizareDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        onSuccess={loadSummary}
      />
    </div>
  );
}
```

**Update packages/client/src/App.tsx:**

Add "Amortizare" to the navigation:
```typescript
const navItems = [
  { path: "/", label: "Acasa" },
  { path: "/mijloace-fixe", label: "Mijloace Fixe" },
  { path: "/amortizare", label: "Amortizare" },  // Add this line
  { path: "/gestiuni", label: "Gestiuni" },
  // ... rest of items
];
```

**Update packages/client/src/main.tsx:**

Add the route for the Amortizare page:
```typescript
import Amortizare from "./pages/Amortizare";

// In the routes array, add:
{
  path: "amortizare",
  element: <Amortizare />,
},
```
  </action>
  <verify>
1. Run the dev server and navigate to /amortizare
2. Verify the page shows stats cards and summary table
3. Click "Genereaza Amortizare" to open the dialog
4. Verify month/year selectors work and show processed status
5. Generate depreciation for a test month and verify success toast
6. Verify summary table updates with new data
  </verify>
  <done>
Amortizare page created with stats cards, summary table, and generation dialog.
User can generate monthly depreciation and view summary by month/year (AMO-02, AMO-05).
  </done>
</task>

</tasks>

<verification>
1. Amortizare page accessible via /amortizare route
2. Navigation includes "Amortizare" link
3. Stats cards show total depreciation, months processed, average per month
4. Summary table shows monthly breakdown with yearly totals
5. Year filter works correctly
6. Generation dialog opens and shows month/year selects
7. Processed months have green checkmark indicator
8. Generation creates records and shows success toast
9. Summary refreshes after successful generation
10. TypeScript compiles without errors
</verification>

<success_criteria>
- User can run monthly depreciation calculation for all active assets (AMO-02)
- User can view depreciation summary by month/year across all assets (AMO-05)
- User sees which months are already processed before generating
- Success/info feedback shows how many assets were processed or skipped
- Page accessible from main navigation
</success_criteria>

<output>
After completion, create `.planning/phases/05-amortizare/05-03-SUMMARY.md`
</output>

---
phase: 06-rapoarte-autentificare
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - packages/client/src/components/auth/AuthContext.tsx
  - packages/client/src/components/auth/ProtectedRoute.tsx
  - packages/client/src/components/auth/LoginForm.tsx
  - packages/client/src/pages/Login.tsx
  - packages/client/src/main.tsx
  - packages/client/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Unauthenticated user is redirected to login page"
    - "User can login with username and password"
    - "User session persists across page refresh"
    - "User can logout and is redirected to login"
  artifacts:
    - path: "packages/client/src/components/auth/AuthContext.tsx"
      provides: "Auth state management with login/logout functions"
      exports: ["AuthProvider", "useAuth"]
    - path: "packages/client/src/components/auth/ProtectedRoute.tsx"
      provides: "Route guard component"
      exports: ["ProtectedRoute"]
    - path: "packages/client/src/pages/Login.tsx"
      provides: "Login page with form"
      exports: ["LoginPage"]
  key_links:
    - from: "packages/client/src/components/auth/AuthContext.tsx"
      to: "/api/auth/me"
      via: "session check on mount"
      pattern: "fetch.*api/auth/me"
    - from: "packages/client/src/components/auth/AuthContext.tsx"
      to: "/api/auth/login"
      via: "login function"
      pattern: "fetch.*api/auth/login"
    - from: "packages/client/src/main.tsx"
      to: "AuthProvider"
      via: "context wrapping"
      pattern: "AuthProvider"
---

<objective>
Create authentication UI components: AuthContext for state management, ProtectedRoute for guarding routes, LoginForm/LoginPage for authentication, and integrate with existing routing.

Purpose: Complete AUTH-01, AUTH-02, AUTH-03 requirements with working frontend
Output: Users must login to access the application, sessions persist across refreshes, users can logout
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-rapoarte-autentificare/06-RESEARCH.md
@.planning/phases/06-rapoarte-autentificare/06-01-SUMMARY.md

# Existing UI patterns
@packages/client/src/main.tsx
@packages/client/src/App.tsx
@packages/client/src/pages/Gestiuni.tsx
@packages/client/src/components/nomenclatoare/GestiuniForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext and ProtectedRoute components</name>
  <files>
    packages/client/src/components/auth/AuthContext.tsx
    packages/client/src/components/auth/ProtectedRoute.tsx
  </files>
  <action>
Create components/auth/AuthContext.tsx:

```typescript
interface User {
  username: string;
}

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  login: (username: string, password: string) => Promise<{ success: boolean; message?: string }>;
  logout: () => Promise<void>;
}
```

Implement AuthProvider:
- useState for user (User | null) and isLoading (boolean, default true)
- useEffect on mount: fetch /api/auth/me to check existing session
  - If success: setUser(data.data)
  - If error/401: setUser(null)
  - Finally: setIsLoading(false)
- login function: POST to /api/auth/login with credentials
  - On success: setUser(data.data), return { success: true }
  - On failure: return { success: false, message: data.message || "Eroare la autentificare" }
- logout function: POST to /api/auth/logout, setUser(null)

Export useAuth hook that uses useContext and throws if used outside AuthProvider.

Create components/auth/ProtectedRoute.tsx:
- Use useAuth() to get user and isLoading
- Use useLocation() from react-router-dom
- If isLoading: return loading spinner or "Se incarca..." text
- If no user: return Navigate to="/login" with state={{ from: location }} replace
- Otherwise: return children

Follow existing component patterns (function export, TypeScript).
  </action>
  <verify>
- File exists at packages/client/src/components/auth/AuthContext.tsx
- File exists at packages/client/src/components/auth/ProtectedRoute.tsx
- Both export required functions/components
- TypeScript compiles without errors: `cd packages/client && bun run tsc --noEmit`
  </verify>
  <done>AuthContext provides auth state and login/logout functions, ProtectedRoute redirects unauthenticated users to /login</done>
</task>

<task type="auto">
  <name>Task 2: Create Login page and form</name>
  <files>
    packages/client/src/components/auth/LoginForm.tsx
    packages/client/src/pages/Login.tsx
  </files>
  <action>
Create components/auth/LoginForm.tsx following existing form patterns:
- Use react-hook-form with zodResolver
- Zod schema: username (min 1, "Introduceti utilizatorul"), password (min 1, "Introduceti parola")
- Use useAuth() to get login function
- Use useNavigate() and useLocation() from react-router-dom
- On submit: call login(), if success navigate to location.state?.from?.pathname || "/"
- Show error message if login fails (use toast from sonner)
- Use shadcn/ui components: Card, CardHeader, CardTitle, CardContent, Form, FormField, FormItem, FormLabel, FormControl, FormMessage, Input, Button

Form layout:
- Card centered on page (max-w-md mx-auto mt-20)
- CardHeader with "Autentificare MiFix" title
- Username input with autoComplete="username"
- Password input (type="password") with autoComplete="current-password"
- Submit button with "Autentificare" label, full width
- Show inline error above button if login fails

Create pages/Login.tsx:
- Simple page component that renders LoginForm
- No navigation bar (login page is standalone)
- Export as LoginPage
  </action>
  <verify>
- File exists at packages/client/src/components/auth/LoginForm.tsx
- File exists at packages/client/src/pages/Login.tsx
- TypeScript compiles: `cd packages/client && bun run tsc --noEmit`
  </verify>
  <done>LoginForm validates input and calls auth API, LoginPage provides standalone login UI</done>
</task>

<task type="auto">
  <name>Task 3: Integrate auth into routing and add logout button</name>
  <files>
    packages/client/src/main.tsx
    packages/client/src/App.tsx
  </files>
  <action>
Update main.tsx:
- Import AuthProvider from components/auth/AuthContext
- Import ProtectedRoute from components/auth/ProtectedRoute
- Import LoginPage from pages/Login
- Add /login route outside the protected routes (directly under root, not as child of App)
- Wrap App with AuthProvider
- Wrap all App children with ProtectedRoute

Router structure:
```typescript
const router = createBrowserRouter([
  {
    path: "/login",
    element: <LoginPage />,
  },
  {
    path: "/",
    element: <AuthProvider><ProtectedRoute><App /></ProtectedRoute></AuthProvider>,
    children: [
      // existing children...
    ],
  },
]);
```

Actually, simpler approach - wrap entire RouterProvider with AuthProvider in the render:
```typescript
<AuthProvider>
  <RouterProvider router={router} />
</AuthProvider>
```

And update router:
```typescript
{
  path: "/login",
  element: <LoginPage />,
},
{
  path: "/",
  element: <ProtectedRoute><App /></ProtectedRoute>,
  children: [...],
}
```

Update App.tsx:
- Import useAuth from components/auth/AuthContext
- Add logout button in navigation bar (right side)
- Use Button variant="ghost" with "Iesire" label
- On click: call logout(), navigate to /login
- Import useNavigate from react-router-dom
- Show current username next to logout button (optional, nice to have)

Add "Rapoarte" to navItems array (path: "/rapoarte", label: "Rapoarte") for the next plan.
  </action>
  <verify>
- Start dev server: `cd packages/client && bun run dev`
- Visit http://localhost:5173 - should redirect to /login
- Login with admin/admin123 - should redirect to home
- Refresh page - should still be logged in (session persists)
- Click "Iesire" button - should logout and redirect to /login
- After logout, visiting any page redirects to /login
  </verify>
  <done>
- /login route shows login page without auth
- All other routes require authentication
- Session persists across browser refresh
- Logout button visible in navigation, logs out and redirects
  </done>
</task>

</tasks>

<verification>
1. Start both server (`bun run dev` in server) and client (`bun run dev` in client)
2. Visit http://localhost:5173 - redirected to /login
3. Enter invalid credentials - shows error
4. Enter admin/admin123 - redirected to home
5. Navigate to /gestiuni - works (authenticated)
6. Refresh browser - still logged in
7. Click logout - redirected to /login
8. Try to visit /gestiuni directly - redirected to /login
</verification>

<success_criteria>
- [ ] AuthContext provides user state, login, logout functions
- [ ] ProtectedRoute redirects unauthenticated users to /login
- [ ] Login page accepts username/password and authenticates
- [ ] Invalid credentials show error message
- [ ] Successful login redirects to originally requested page
- [ ] Session persists across page refresh (cookie-based)
- [ ] Logout button visible in navigation bar
- [ ] Logout clears session and redirects to login
</success_criteria>

<output>
After completion, create `.planning/phases/06-rapoarte-autentificare/06-02-SUMMARY.md`
</output>

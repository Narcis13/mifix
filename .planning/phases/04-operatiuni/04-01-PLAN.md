---
phase: 04-operatiuni
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/db/schema.ts
  - packages/server/src/routes/operatiuni.ts
  - packages/server/src/validation/operatiuni-schemas.ts
  - packages/server/src/index.ts
  - packages/shared/src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Transfer endpoint updates asset gestiune and creates transaction record atomically"
    - "Casare endpoint updates asset stare to 'casat' and creates transaction record atomically"
    - "Declasare endpoint reduces asset valoareRamasa and creates transaction record atomically"
    - "Operations are rejected for non-active assets"
  artifacts:
    - path: "packages/server/src/routes/operatiuni.ts"
      provides: "POST endpoints for /transfer-gestiune, /transfer-loc, /casare, /declasare"
      exports: ["operatiuniRoutes"]
    - path: "packages/server/src/validation/operatiuni-schemas.ts"
      provides: "Zod schemas for each operation type"
      exports: ["transferGestiuneSchema", "transferLocSchema", "casareSchema", "declasareSchema"]
  key_links:
    - from: "packages/server/src/routes/operatiuni.ts"
      to: "packages/server/src/db/schema.ts"
      via: "db.transaction() wrapping asset update + tranzactii insert"
      pattern: "db\\.transaction\\(async \\(tx\\)"
    - from: "packages/server/src/routes/operatiuni.ts"
      to: "packages/shared/src/types/index.ts"
      via: "Operation response types"
---

<objective>
Create database schema migration and Operatiuni API endpoints with atomic transactions

Purpose: Enable all asset lifecycle operations (transfer, casare, declasare) with proper audit trail and data integrity through database transactions.

Output:
- Schema migration adding locFolosinta fields to tranzactii table
- POST /api/operatiuni/transfer-gestiune endpoint
- POST /api/operatiuni/transfer-loc endpoint
- POST /api/operatiuni/casare endpoint
- POST /api/operatiuni/declasare endpoint
- Zod validation schemas for each operation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-operatiuni/04-RESEARCH.md

# Key existing files
@packages/server/src/db/schema.ts
@packages/server/src/routes/mijloace-fixe.ts
@packages/shared/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add locFolosinta fields to tranzactii schema and update types</name>
  <files>
    packages/server/src/db/schema.ts
    packages/shared/src/types/index.ts
  </files>
  <action>
1. In packages/server/src/db/schema.ts, add to the tranzactii table definition:
   - locFolosintaSursaId: int("loc_folosinta_sursa_id")
   - locFolosintaDestinatieId: int("loc_folosinta_destinatie_id")

2. Update tranzactiiRelations to include the new locFolosinta relations:
   - locFolosintaSursa: one(locuriUilizare, { fields: [tranzactii.locFolosintaSursaId], references: [locuriUilizare.id] })
   - locFolosintaDestinatie: one(locuriUilizare, { fields: [tranzactii.locFolosintaDestinatieId], references: [locuriUilizare.id] })

3. In packages/shared/src/types/index.ts, verify Tranzactie interface already has locFolosintaSursaId and locFolosintaDestinatieId (they are already there from initial design).

4. Run `bun run db:push` from packages/server to apply schema changes to database.
  </action>
  <verify>
Run `bun run db:push` completes without errors. Query database to confirm new columns exist:
`mysql -e "DESCRIBE tranzactii" | grep loc_folosinta`
  </verify>
  <done>
tranzactii table has loc_folosinta_sursa_id and loc_folosinta_destinatie_id columns. Drizzle relations updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Operatiuni validation schemas</name>
  <files>
    packages/server/src/validation/operatiuni-schemas.ts
  </files>
  <action>
Create packages/server/src/validation/operatiuni-schemas.ts with:

1. transferGestiuneSchema:
   - mijlocFixId: z.number().min(1, "Mijloc fix obligatoriu")
   - gestiuneDestinatieId: z.number().min(1, "Gestiune destinatie obligatorie")
   - locFolosintaDestinatieId: z.number().nullable().optional()
   - dataOperare: z.string().min(1, "Data operarii obligatorie")
   - documentNumar: z.string().max(100).optional()
   - documentData: z.string().optional()
   - observatii: z.string().max(500).optional()

2. transferLocSchema:
   - mijlocFixId: z.number().min(1, "Mijloc fix obligatoriu")
   - locFolosintaDestinatieId: z.number().min(1, "Loc folosinta destinatie obligatoriu")
   - dataOperare: z.string().min(1, "Data operarii obligatorie")
   - documentNumar: z.string().max(100).optional()
   - documentData: z.string().optional()
   - observatii: z.string().max(500).optional()

3. casareSchema:
   - mijlocFixId: z.number().min(1, "Mijloc fix obligatoriu")
   - dataOperare: z.string().min(1, "Data operarii obligatorie")
   - motivCasare: z.string().min(1, "Motivul casarii obligatoriu").max(500)
   - documentNumar: z.string().max(100).optional()
   - documentData: z.string().optional()
   - observatii: z.string().max(500).optional()

4. declasareSchema:
   - mijlocFixId: z.number().min(1, "Mijloc fix obligatoriu")
   - valoareReducere: z.string().min(1, "Valoarea reducerii obligatorie")
   - dataOperare: z.string().min(1, "Data operarii obligatorie")
   - motivDeclasare: z.string().min(1, "Motivul declasarii obligatoriu").max(500)
   - documentNumar: z.string().max(100).optional()
   - documentData: z.string().optional()
   - observatii: z.string().max(500).optional()

Export all schemas.
  </action>
  <verify>
TypeScript compiles without errors: `cd packages/server && bun run build` (or just `tsc --noEmit`)
  </verify>
  <done>
All four validation schemas (transferGestiuneSchema, transferLocSchema, casareSchema, declasareSchema) created and exported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Operatiuni API routes with atomic transactions</name>
  <files>
    packages/server/src/routes/operatiuni.ts
    packages/server/src/index.ts
  </files>
  <action>
Create packages/server/src/routes/operatiuni.ts:

1. Import dependencies:
   - Hono, zValidator
   - db, mijloaceFixe, tranzactii, gestiuni, locuriUilizare from schema
   - eq from drizzle-orm
   - Money class from shared
   - All schemas from operatiuni-schemas.ts

2. POST /transfer-gestiune:
   - Validate with transferGestiuneSchema
   - Use db.transaction():
     a. Fetch asset, verify stare === "activ"
     b. If not active, return 400 with error message
     c. Verify gestiuneDestinatieId exists and is different from current
     d. Update mijloaceFixe: set gestiuneId, locFolosintaId (null if changing gestiune, or new loc if provided)
     e. Insert tranzactii with tip="transfer", gestiuneSursaId, gestiuneDestinatieId, locFolosintaSursaId, locFolosintaDestinatieId
   - Return { success: true }

3. POST /transfer-loc:
   - Validate with transferLocSchema
   - Use db.transaction():
     a. Fetch asset, verify stare === "activ"
     b. Verify locFolosintaDestinatieId belongs to same gestiune as asset
     c. Update mijloaceFixe: set locFolosintaId
     d. Insert tranzactii with tip="transfer", only locFolosintaSursaId, locFolosintaDestinatieId (no gestiune change)
   - Return { success: true }

4. POST /casare:
   - Validate with casareSchema
   - Use db.transaction():
     a. Fetch asset, verify stare === "activ"
     b. Update mijloaceFixe: set stare="casare", dataIesire=dataOperare, motivIesire=motivCasare
     c. Insert tranzactii with tip="casare", descriere=motivCasare
   - Return { success: true }

5. POST /declasare:
   - Validate with declasareSchema
   - Use db.transaction():
     a. Fetch asset, verify stare === "activ"
     b. Parse valoareReducere with Money.fromDb(), verify it doesn't exceed valoareRamasa
     c. Calculate new valoareRamasa = current - reducere using Money class
     d. Update mijloaceFixe: set valoareRamasa to new value
     e. Insert tranzactii with tip="declasare", valoareOperatie=reducere, valoareInainte, valoareDupa, descriere=motivDeclasare
   - Return { success: true }

Export operatiuniRoutes.

Register in packages/server/src/index.ts:
- Import operatiuniRoutes
- Add app.route("/api/operatiuni", operatiuniRoutes)

IMPORTANT: Use db.transaction() for atomicity. If any step fails, the entire operation rolls back.
  </action>
  <verify>
Test with curl commands:

1. Create test asset first if needed
2. Test transfer-gestiune:
   curl -X POST http://localhost:3001/api/operatiuni/transfer-gestiune \
     -H "Content-Type: application/json" \
     -d '{"mijlocFixId": 1, "gestiuneDestinatieId": 2, "dataOperare": "2026-01-23"}'

3. Test casare (on different asset or after creating new one):
   curl -X POST http://localhost:3001/api/operatiuni/casare \
     -H "Content-Type: application/json" \
     -d '{"mijlocFixId": 2, "dataOperare": "2026-01-23", "motivCasare": "Uzura fizica"}'

All should return { success: true } and create corresponding tranzactii records.
  </verify>
  <done>
Four operation endpoints created: /transfer-gestiune, /transfer-loc, /casare, /declasare. All use db.transaction() for atomicity. Operations on non-active assets return 400 error.
  </done>
</task>

</tasks>

<verification>
1. Schema migration applied successfully (locFolosinta columns in tranzactii)
2. All four endpoints respond with proper validation errors for invalid input
3. Operations create transaction records in tranzactii table
4. Operations on non-active assets are rejected with 400 status
5. Declasare with excessive reduction amount is rejected
6. TypeScript compiles without errors
</verification>

<success_criteria>
- POST /api/operatiuni/transfer-gestiune updates asset gestiuneId and creates transfer tranzactie
- POST /api/operatiuni/transfer-loc updates asset locFolosintaId and creates transfer tranzactie
- POST /api/operatiuni/casare updates asset stare to "casare" and creates casare tranzactie
- POST /api/operatiuni/declasare reduces asset valoareRamasa and creates declasare tranzactie
- All operations are atomic (fail together or succeed together)
- Non-active assets cannot be operated on
</success_criteria>

<output>
After completion, create `.planning/phases/04-operatiuni/04-01-SUMMARY.md`
</output>

---
phase: 03-mijloace-fixe-core
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/server/src/routes/mijloace-fixe.ts
  - packages/server/src/validation/schemas.ts
  - packages/server/src/index.ts
autonomous: true

must_haves:
  truths:
    - "GET /mijloace-fixe returns paginated list with filtering"
    - "GET /mijloace-fixe/:id returns asset with all joined relations"
    - "POST /mijloace-fixe creates new asset with validation"
    - "PUT /mijloace-fixe/:id updates asset"
    - "Duplicate numarInventar returns 400 with clear error message"
  artifacts:
    - path: "packages/server/src/routes/mijloace-fixe.ts"
      provides: "MijlocFix CRUD routes with filtering and joins"
      exports: ["mijloaceFixeRoutes"]
    - path: "packages/server/src/validation/schemas.ts"
      provides: "MijlocFix validation schemas"
      contains: "insertMijlocFixSchema"
  key_links:
    - from: "packages/server/src/index.ts"
      to: "/mijloace-fixe"
      via: "route registration"
      pattern: "mijloaceFixeRoutes"
    - from: "packages/server/src/routes/mijloace-fixe.ts"
      to: "db.mijloaceFixe"
      via: "Drizzle queries with joins"
      pattern: "leftJoin.*clasificari"
---

<objective>
Create complete MijloaceFixe API with CRUD operations, filtering, pagination, and relation joins.

Purpose: Backend foundation for all asset operations - list, detail, create, edit.
Output: Fully functional /mijloace-fixe API endpoints covering MF-01 (create), MF-02 (list+filter), MF-03 (detail), MF-04 (update), MF-05 (unique validation).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-mijloace-fixe-core/03-CONTEXT.md
@.planning/phases/03-mijloace-fixe-core/03-RESEARCH.md
@packages/server/src/db/schema.ts
@packages/server/src/routes/clasificari.ts
@packages/server/src/routes/gestiuni.ts
@packages/shared/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MijlocFix validation schemas</name>
  <files>packages/server/src/validation/schemas.ts</files>
  <action>
Add MijlocFix validation schemas to packages/server/src/validation/schemas.ts:

```typescript
// ============================================================================
// Mijloace Fixe - Fixed Assets
// ============================================================================
export const insertMijlocFixSchema = createInsertSchema(mijloaceFixe, {
  numarInventar: (schema) => schema
    .min(1, "Numar inventar obligatoriu")
    .max(50, "Numar inventar maxim 50 caractere"),
  denumire: (schema) => schema
    .min(1, "Denumire obligatorie")
    .max(255, "Denumire maxim 255 caractere"),
  descriere: (schema) => schema
    .max(1000, "Descriere maxim 1000 caractere")
    .optional(),
  clasificareCod: (schema) => schema
    .min(1, "Clasificare obligatorie"),
  gestiuneId: (schema) => schema
    .min(1, "Gestiune obligatorie"),
  valoareInitiala: (schema) => schema
    .min(1, "Valoare initiala obligatorie"),
  valoareInventar: (schema) => schema
    .min(1, "Valoare inventar obligatorie"),
  durataNormala: (schema) => schema
    .min(1, "Durata normala obligatorie"),
  observatii: (schema) => schema
    .max(1000, "Observatii maxim 1000 caractere")
    .optional(),
}).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  valoareAmortizata: true,  // Computed
  durataRamasa: true,       // Computed
  cotaAmortizareLunara: true, // Computed
});

export type InsertMijlocFix = z.infer<typeof insertMijlocFixSchema>;

export const updateMijlocFixSchema = insertMijlocFixSchema.partial();
export type UpdateMijlocFix = z.infer<typeof updateMijlocFixSchema>;
```

Also import mijloaceFixe from schema at the top of the file.
  </action>
  <verify>
Run `bun run build` from packages/server - TypeScript compiles without errors.
  </verify>
  <done>MijlocFix validation schemas created with all field validations</done>
</task>

<task type="auto">
  <name>Task 2: Create MijloaceFixe API routes</name>
  <files>
    packages/server/src/routes/mijloace-fixe.ts
    packages/server/src/index.ts
  </files>
  <action>
Create packages/server/src/routes/mijloace-fixe.ts with full CRUD:

**1. GET / - List with filtering and pagination:**

Query params:
- search (string): Filter by numarInventar OR denumire (LIKE)
- gestiuneId (number): Filter by gestiune
- locFolosintaId (number): Filter by loc folosinta
- stare (string): Filter by stare (activ, casare, etc.)
- grupa (string): Filter by clasificare.grupa
- page (number, default 1)
- pageSize (number, default 20)

Implementation pattern from clasificari.ts:
- Build dynamic conditions array
- Use and(...conditions) for whereClause
- Count total for pagination
- Return PaginatedResponse

Select with LEFT JOINs to include:
- clasificari (cod, denumire, grupa)
- gestiuni (cod, denumire)
- locuriUilizare (denumire)
- surseFinantare (denumire)
- conturi (simbol, denumire)
- tipuriDocument (denumire)

Order by denumire alphabetically.

**2. GET /:id - Single asset with full relations:**

Return all fields plus nested relation objects:
- clasificare: full Clasificare object
- gestiune: full Gestiune object
- locFolosinta: full LocFolosinta object (if exists)
- sursaFinantare: full SursaFinantare object (if exists)
- cont: full Cont object (if exists)
- tipDocument: full TipDocument object (if exists)

Use LEFT JOINs to get all related data in single query.

**3. POST / - Create new asset:**

Validation with zValidator using insertMijlocFixSchema.

IMPORTANT: Check numarInventar uniqueness BEFORE insert:
```typescript
const existing = await db
  .select({ id: mijloaceFixe.id })
  .from(mijloaceFixe)
  .where(eq(mijloaceFixe.numarInventar, data.numarInventar))
  .limit(1);

if (existing.length > 0) {
  return c.json<ApiResponse>({
    success: false,
    message: "Numarul de inventar exista deja",
    errors: { numarInventar: ["Numarul de inventar trebuie sa fie unic"] }
  }, 400);
}
```

Compute derived fields before insert:
- valoareAmortizata: "0.00" (new asset)
- valoareRamasa: same as valoareInventar
- durataRamasa: same as durataNormala
- cotaAmortizareLunara: valoareInventar / durataNormala (use Money class from shared)

**4. PUT /:id - Update asset:**

Validation with zValidator using updateMijlocFixSchema.

Check numarInventar uniqueness excluding current record:
```typescript
const existingForUpdate = await db
  .select({ id: mijloaceFixe.id })
  .from(mijloaceFixe)
  .where(
    and(
      eq(mijloaceFixe.numarInventar, data.numarInventar),
      sql`${mijloaceFixe.id} != ${id}`
    )
  )
  .limit(1);
```

Recalculate derived fields if valoareInventar or durataNormala changed.

**5. Register in index.ts:**

```typescript
import { mijloaceFixeRoutes } from "./routes/mijloace-fixe";
app.route("/mijloace-fixe", mijloaceFixeRoutes);
```
  </action>
  <verify>
1. Server starts: `bun run dev`

2. Test list endpoint:
   `curl "http://localhost:3000/mijloace-fixe"` returns paginated empty result

3. Test create with validation error:
   `curl -X POST http://localhost:3000/mijloace-fixe -H "Content-Type: application/json" -d '{}'`
   Returns 400 with validation errors

4. Test create with valid data (need existing gestiune, clasificare):
   ```bash
   curl -X POST http://localhost:3000/mijloace-fixe \
     -H "Content-Type: application/json" \
     -d '{
       "numarInventar": "MF-001",
       "denumire": "Calculator HP",
       "clasificareCod": "2.1.24.1.1",
       "gestiuneId": 1,
       "dataAchizitie": "2024-01-15",
       "valoareInitiala": "5000.00",
       "valoareInventar": "5000.00",
       "valoareRamasa": "5000.00",
       "durataNormala": 48,
       "durataRamasa": 48,
       "cotaAmortizareLunara": "104.17",
       "stare": "activ"
     }'
   ```
   Returns 201 with created asset

5. Test duplicate numarInventar:
   Same curl as above - returns 400 "Numarul de inventar exista deja"

6. Test get by id:
   `curl http://localhost:3000/mijloace-fixe/1` returns asset with relations

7. Test filtering:
   `curl "http://localhost:3000/mijloace-fixe?search=Calculator"` returns matching assets
  </verify>
  <done>
- GET /mijloace-fixe returns paginated list with filtering
- GET /mijloace-fixe/:id returns asset with all joined relations
- POST /mijloace-fixe creates new asset with validation
- PUT /mijloace-fixe/:id updates asset
- Duplicate numarInventar returns 400 with clear error
  </done>
</task>

</tasks>

<verification>
1. All endpoints respond correctly
2. Filtering works (search, gestiuneId, stare)
3. Pagination returns correct totals and pages
4. Relations are populated in responses
5. Unique constraint validation works
6. TypeScript builds without errors
</verification>

<success_criteria>
- Complete CRUD API for MijloaceFixe
- Server-side filtering by gestiune, stare, text search
- Pagination with total count
- Full relation data in responses
- numarInventar uniqueness validated
</success_criteria>

<output>
After completion, create `.planning/phases/03-mijloace-fixe-core/03-02-SUMMARY.md`
</output>
